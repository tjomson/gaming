
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>usertype memory &#8212; Sol 2.18.1 documentation</title>
    <link rel="stylesheet" href="../_static/sol2.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/search-fix.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="unique_usertype_traits&lt;T&gt;" href="unique_usertype_traits.html" />
    <link rel="prev" title="simple_usertype&lt;T&gt;" href="simple_usertype.html" /> 
  </head><body>
      <div class="header" role="banner"> 
	<div class="header-left">
		<h1 class="heading"><a href="../index.html">
          <span>Sol 2.18.1 documentation</span></a></h1>
        <h2 class="heading"><span>usertype memory</span></h2>
	</div>
	<div class="header-right">
		<h3>Search the Documentation</h3>
		<form action="../search.html" method="get">
			<input type="text" name="q" value="">
			<input type="submit" value="search">
		</form>
	</div>

      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="simple_usertype.html">simple_usertype&lt;T&gt;</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="unique_usertype_traits.html">unique_usertype_traits&lt;T&gt;</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="usertype-memory">
<h1>usertype memory<a class="headerlink" href="#usertype-memory" title="Permalink to this headline">¶</a></h1>
<p><em>memory layout of usertypes</em></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Sol does not take ownership of raw pointers, returned from functions or set through the <code class="docutils literal notranslate"><span class="pre">set</span></code> functions. Return a value, a <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>, a <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> of some kind, or hook up the <a class="reference internal" href="unique_usertype_traits.html"><span class="doc">unique usertypes traits</span></a> to work for some specific handle structure you use (AKA, for <code class="docutils literal notranslate"><span class="pre">boost::shared_ptr</span></code>).</p>
</div>
<p>The userdata generated by Sol has a specific layout, depending on how Sol recognizes userdata passed into it. All of the referred to metatable names are generated from the name of the class itself. Note that we use 1 metatable per the 3 styles listed below, plus 1 additional metatable that is used for the actual table that you bind with the name when calling <code class="docutils literal notranslate"><span class="pre">table::new/set_(simple_)usertype</span></code>.</p>
<p>In general, we always insert a <code class="docutils literal notranslate"><span class="pre">T*</span></code> in the first <code class="docutils literal notranslate"><span class="pre">sizeof(T*)</span></code> bytes, so the any framework that pulls out those first bytes expecting a pointer will work. The rest of the data has some different alignments and contents based on what it’s used for and how it’s used.</p>
<div class="section" id="to-retrieve-a-t">
<h2>To retrieve a <code class="docutils literal notranslate"><span class="pre">T</span></code><a class="headerlink" href="#to-retrieve-a-t" title="Permalink to this headline">¶</a></h2>
<p>If you want to retrieve a <code class="docutils literal notranslate"><span class="pre">T*</span></code> pointer to the data managed by a sol2 userdata and are not using sol2’s abstractions to do it (e.g., messing with the plain Lua C API), simply use <code class="docutils literal notranslate"><span class="pre">lua_touserdata</span></code> to get the <code class="docutils literal notranslate"><span class="pre">void*</span></code> pointer. Then, execute a <code class="docutils literal notranslate"><span class="pre">T*</span> <span class="pre">object_pointer</span> <span class="pre">=</span> <span class="pre">*static_cast&lt;T**&gt;(the_void_pointer);</span></code>. Every type pushed into C++ that is classified as a userdata (e.g., all user-defined objects that are not covered by the stack abstraction’s basic types) can be retrieved in this format, whether they are values or pointers or <code class="docutils literal notranslate"><span class="pre">unique_ptr</span></code>. The reasons for why this works is below.</p>
</div>
<div class="section" id="for-t">
<h2>For <code class="docutils literal notranslate"><span class="pre">T</span></code><a class="headerlink" href="#for-t" title="Permalink to this headline">¶</a></h2>
<p>These are classified with a metatable name generally derived from the class name itself.</p>
<p>The data layout for references is as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>        <span class="n">T</span><span class="o">*</span>        <span class="o">|</span>               <span class="n">T</span>              <span class="o">|</span>
<span class="o">^-</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span> <span class="n">bytes</span><span class="o">-^-</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">actual</span> <span class="n">data</span><span class="o">-^</span>
</pre></div>
</div>
<p>Lua will clean up the memory itself but does not know about any destruction semantics T may have imposed, so when we destroy this data we simply call the destructor to destroy the object and leave the memory changes to for lua to handle after the “__gc” method exits.</p>
</div>
<div class="section" id="id1">
<h2>For <code class="docutils literal notranslate"><span class="pre">T*</span></code><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>These are classified as a separate <code class="docutils literal notranslate"><span class="pre">T*</span></code> metatable, essentially the “reference” table. Things passed to Sol as a pointer or as a <code class="docutils literal notranslate"><span class="pre">std::reference&lt;T&gt;</span></code> are considered to be references, and thusly do not have a <code class="docutils literal notranslate"><span class="pre">__gc</span></code> (garbage collection) method by default. All raw pointers are non-owning pointers in C++. If you’re working with a C API, provide a wrapper around pointers that are supposed to own data and use the constructor/destructor idioms (e.g., with an internal <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>) to keep things clean.</p>
<p>The data layout for data that only refers is as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>        <span class="n">T</span><span class="o">*</span>        <span class="o">|</span>
<span class="o">^-</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span> <span class="n">bytes</span><span class="o">-^</span>
</pre></div>
</div>
<p>That is it. No destruction semantics need to be called.</p>
</div>
<div class="section" id="for-std-unique-ptr-t-d-and-std-shared-ptr-t">
<h2>For <code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;T,</span> <span class="pre">D&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;T&gt;</span></code><a class="headerlink" href="#for-std-unique-ptr-t-d-and-std-shared-ptr-t" title="Permalink to this headline">¶</a></h2>
<p>These are classified as <a class="reference internal" href="unique_usertype_traits.html#unique-usertype"><span class="std std-ref">“unique usertypes”</span></a>, and have a special metatable for them as well. The special metatable is either generated when you add the usertype to Lua using <a class="reference internal" href="table.html#id1"><span class="std std-ref">set_usertype</span></a> or when you first push one of these special types. In addition to the data, a deleter function that understands the following layout is injected into the userdata layout.</p>
<p>The data layout for these kinds of types is as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>        <span class="n">T</span><span class="o">*</span>        <span class="o">|</span>    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">function_pointer</span>    <span class="o">|</span>               <span class="n">T</span>               <span class="o">|</span>
<span class="o">^-</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span> <span class="n">bytes</span><span class="o">-^-</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">))</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">deleter</span><span class="o">-^-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">actal</span> <span class="n">data</span> <span class="o">-^</span>
</pre></div>
</div>
<p>Note that we put a special deleter function before the actual data. This is because the custom deleter must know where the offset to the data is and where the special deleter is. In other words, fixed-size-fields come before any variably-sized data (T can be known at compile time, but when serialized into Lua in this manner it becomes a runtime entity). Sol just needs to know about <code class="docutils literal notranslate"><span class="pre">T*</span></code> and the userdata (and userdata metatable) to work, everything else is for preserving construction / destruction semantics.</p>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="simple_usertype.html">simple_usertype&lt;T&gt;</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="unique_usertype_traits.html">unique_usertype_traits&lt;T&gt;</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, ThePhD.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>