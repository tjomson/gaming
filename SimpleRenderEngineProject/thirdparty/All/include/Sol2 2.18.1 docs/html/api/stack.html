
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>stack namespace &#8212; Sol 2.18.1 documentation</title>
    <link rel="stylesheet" href="../_static/sol2.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/search-fix.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="light&lt;T&gt;/user&lt;T&gt;" href="user.html" />
    <link rel="prev" title="resolve" href="resolve.html" /> 
  </head><body>
      <div class="header" role="banner"> 
	<div class="header-left">
		<h1 class="heading"><a href="../index.html">
          <span>Sol 2.18.1 documentation</span></a></h1>
        <h2 class="heading"><span>stack namespace</span></h2>
	</div>
	<div class="header-right">
		<h3>Search the Documentation</h3>
		<form action="../search.html" method="get">
			<input type="text" name="q" value="">
			<input type="submit" value="search">
		</form>
	</div>

      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="resolve.html">resolve</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="user.html">light&lt;T&gt;/user&lt;T&gt;</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="stack-namespace">
<h1>stack namespace<a class="headerlink" href="#stack-namespace" title="Permalink to this headline">¶</a></h1>
<p><em>the nitty-gritty core abstraction layer over Lua</em></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">stack</span>
</pre></div>
</div>
<p>If you find that the higher level abstractions are not meeting your needs, you may want to delve into the <code class="docutils literal notranslate"><span class="pre">stack</span></code> namespace to try and get more out of Sol. <code class="docutils literal notranslate"><span class="pre">stack.hpp</span></code> and the <code class="docutils literal notranslate"><span class="pre">stack</span></code> namespace define several utilities to work with Lua, including pushing / popping utilities, getters, type checkers, Lua call helpers and more. This namespace is not thoroughly documented as the majority of its interface is mercurial and subject to change between releases to either heavily boost performance or improve the Sol <a class="reference internal" href="api-top.html"><span class="doc">api</span></a>.</p>
<p>Working at this level of the stack can be enhanced by understanding how the <a class="reference external" href="https://www.lua.org/pil/24.2.html">Lua stack works in general</a> and then supplementing it with the objects and items here.</p>
<p>There are, however, a few <a class="reference internal" href="#extension-points"><span class="std std-ref">template customization points</span></a> that you may use for your purposes and a handful of potentially handy functions. These may help if you’re trying to slim down the code you have to write, or if you want to make your types behave differently throughout the Sol stack. Note that overriding the defaults <strong>can</strong> throw out many of the safety guarantees Sol provides: therefore, modify the <a class="reference internal" href="#extension-points"><span class="std std-ref">extension points</span></a> at your own discretion.</p>
<div class="section" id="structures">
<h2>structures<a class="headerlink" href="#structures" title="Permalink to this headline">¶</a></h2>
<div class="literal-block-wrapper docutils container" id="stack-record">
<div class="code-block-caption"><span class="caption-text">struct: record</span><a class="headerlink" href="#stack-record" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">record</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">last</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">used</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>This structure is for advanced usage with <a class="reference internal" href="#stack-get"><span class="std std-ref">stack::get</span></a> and <a class="reference internal" href="#stack-get"><span class="std std-ref">stack::check_get</span></a>. When overriding the customization points, it is important to call the <code class="docutils literal notranslate"><span class="pre">use</span></code> member function on this class with the amount of things you are pulling from the stack. <code class="docutils literal notranslate"><span class="pre">used</span></code> contains the total accumulation of items produced. <code class="docutils literal notranslate"><span class="pre">last</span></code> is the number of items gotten from the stack with the last operation (not necessarily popped from the stack). In all trivial cases for types, <code class="docutils literal notranslate"><span class="pre">last</span> <span class="pre">==</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">used</span> <span class="pre">==</span> <span class="pre">1</span></code> after an operation; structures such as <code class="docutils literal notranslate"><span class="pre">std::pair</span></code> and <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> may pull more depending on the classes it contains.</p>
<p>When overriding the <a class="reference internal" href="../tutorial/customization.html"><span class="doc">customization points</span></a>, please note that this structure should enable you to push multiple return values and get multiple return values to the stack, and thus be able to seamlessly pack/unpack return values from Lua into a single C++ struct, and vice-versa. This functionality is only recommended for people who need to customize the library further than the basics. It is also a good way to add support for the type and propose it back to the original library so that others may benefit from your work.</p>
<p>Note that customizations can also be put up on a separate page here, if individuals decide to make in-depth custom ones for their framework or other places.</p>
<div class="literal-block-wrapper docutils container" id="stack-probe-struct">
<div class="code-block-caption"><span class="caption-text">struct: probe</span><a class="headerlink" href="#stack-probe-struct" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">probe</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">success</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">levels</span><span class="p">;</span>

        <span class="n">probe</span><span class="p">(</span><span class="kt">bool</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">);</span>
        <span class="k">operator</span> <span class="nf">bool</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>This struct is used for showing whether or not a <a class="reference internal" href="#stack-probe-get-field"><span class="std std-ref">probing get_field</span></a> was successful or not.</p>
</div>
<div class="section" id="members">
<h2>members<a class="headerlink" href="#members" title="Permalink to this headline">¶</a></h2>
<div class="literal-block-wrapper docutils container" id="stack-call-lua">
<div class="code-block-caption"><span class="caption-text">function: call_lua</span><a class="headerlink" href="#stack-call-lua" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">check_args</span> <span class="o">=</span> <span class="n">stack_detail</span><span class="o">::</span><span class="n">default_check_arguments</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Fx</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">FxArgs</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="n">call_lua</span><span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">Fx</span><span class="o">&amp;&amp;</span> <span class="n">fx</span><span class="p">,</span> <span class="n">FxArgs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">fxargs</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>This function is helpful for when you bind to a raw C function but need sol’s abstractions to save you the agony of setting up arguments and know how <a class="reference external" href="https://www.lua.org/pil/26.html">calling C functions works</a>. The <code class="docutils literal notranslate"><span class="pre">start</span></code> parameter tells the function where to start pulling arguments from. The parameter <code class="docutils literal notranslate"><span class="pre">fx</span></code>  is what’s supposed to be called. Extra arguments are passed to the function directly. There are intermediate versions of this (<code class="docutils literal notranslate"><span class="pre">sol::stack::call_into_lua</span></code> and similar) for more advanced users, but they are not documented as they are subject to change to improve performance or adjust the API accordingly in later iterations of sol2. Use the more advanced versions at your own peril.</p>
<div class="literal-block-wrapper docutils container" id="stack-get">
<div class="code-block-caption"><span class="caption-text">function: get</span><a class="headerlink" href="#stack-get" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">get</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">get</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">record</span><span class="o">&amp;</span> <span class="n">tracking</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<p>Retrieves the value of the object at <code class="docutils literal notranslate"><span class="pre">index</span></code> in the stack. The return type varies based on <code class="docutils literal notranslate"><span class="pre">T</span></code>: with primitive types, it is usually <code class="docutils literal notranslate"><span class="pre">T</span></code>: for all unrecognized <code class="docutils literal notranslate"><span class="pre">T</span></code>, it is generally a <code class="docutils literal notranslate"><span class="pre">T&amp;</span></code> or whatever the extension point <a class="reference internal" href="#getter"><span class="std std-ref">stack::getter&lt;T&gt;</span></a> implementation returns. The type <code class="docutils literal notranslate"><span class="pre">T</span></code> has top-level <code class="docutils literal notranslate"><span class="pre">const</span></code> qualifiers and reference modifiers removed before being forwarded to the extension point <a class="reference internal" href="#getter"><span class="std std-ref">stack::getter&lt;T&gt;</span></a> struct. <code class="docutils literal notranslate"><span class="pre">stack::get</span></code> will default to forwarding all arguments to the <a class="reference internal" href="#stack-check-get"><span class="std std-ref">stack::check_get</span></a> function with a handler of <code class="docutils literal notranslate"><span class="pre">type_panic</span></code> to strongly alert for errors, if you ask for the <a class="reference internal" href="../safety.html"><span class="doc">safety</span></a>.</p>
<p>You may also retrieve an <a class="reference internal" href="optional.html"><span class="doc">sol::optional&lt;T&gt;</span></a> from this as well, to have it attempt to not throw errors when performing the get and the type is not correct.</p>
<div class="literal-block-wrapper docutils container" id="stack-check">
<div class="code-block-caption"><span class="caption-text">function: check</span><a class="headerlink" href="#stack-check" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">check</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Handler</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">check</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Handler</span><span class="o">&amp;&amp;</span> <span class="n">handler</span> <span class="p">)</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Handler</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">check</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Handler</span><span class="o">&amp;&amp;</span> <span class="n">handler</span><span class="p">,</span> <span class="n">record</span><span class="o">&amp;</span> <span class="n">tracking</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<p>Checks if the object at <code class="docutils literal notranslate"><span class="pre">index</span></code> is of type <code class="docutils literal notranslate"><span class="pre">T</span></code>. If it is not, it will call the <code class="docutils literal notranslate"><span class="pre">handler</span></code> function with <code class="docutils literal notranslate"><span class="pre">lua_State*</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">type</span></code> expected, and <code class="docutils literal notranslate"><span class="pre">type</span></code> actual as arguments. If you do not pass your own handler, a <code class="docutils literal notranslate"><span class="pre">no_panic</span></code> handler will be passed.</p>
<div class="literal-block-wrapper docutils container" id="stack-check-get">
<div class="code-block-caption"><span class="caption-text">function: check_get</span><a class="headerlink" href="#stack-check-get" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">check_get</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Handler</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">check_get</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Handler</span><span class="o">&amp;&amp;</span> <span class="n">handler</span><span class="p">,</span> <span class="n">record</span><span class="o">&amp;</span> <span class="n">tracking</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<p>Retrieves the value of the object at <code class="docutils literal notranslate"><span class="pre">index</span></code> in the stack, but does so safely. It returns an <code class="docutils literal notranslate"><span class="pre">optional&lt;U&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">U</span></code> in this case is the return type deduced from <code class="docutils literal notranslate"><span class="pre">stack::get&lt;T&gt;</span></code>. This allows a person to properly check if the type they’re getting is what they actually want, and gracefully handle errors when working with the stack if they so choose to. You can define <code class="docutils literal notranslate"><span class="pre">SOL_CHECK_ARGUMENTS</span></code> to turn on additional <a class="reference internal" href="../safety.html"><span class="doc">safety</span></a>, in which <code class="docutils literal notranslate"><span class="pre">stack::get</span></code> will default to calling this version of the function with a handler of <code class="docutils literal notranslate"><span class="pre">type_panic</span></code> to strongly alert for errors and help you track bugs if you suspect something might be going wrong in your system.</p>
<div class="literal-block-wrapper docutils container" id="stack-push">
<div class="code-block-caption"><span class="caption-text">function: push</span><a class="headerlink" href="#stack-push" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// push T inferred from call site, pass args... through to extension point</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">push</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">item</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span>

<span class="c1">// push T that is explicitly specified, pass args... through to extension point</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Arg</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">push</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">Arg</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span>

<span class="c1">// recursively call the the above &quot;push&quot; with T inferred, one for each argument</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">multi_push</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<p>Based on how it is called, pushes a variable amount of objects onto the stack. in 99% of cases, returns for 1 object pushed onto the stack. For the case of a <code class="docutils literal notranslate"><span class="pre">std::tuple&lt;...&gt;</span></code>, it recursively pushes each object contained inside the tuple, from left to right, resulting in a variable number of things pushed onto the stack (this enables multi-valued returns when binding a C++ function to a Lua). Can be called with <code class="docutils literal notranslate"><span class="pre">sol::stack::push&lt;T&gt;(</span> <span class="pre">L,</span> <span class="pre">args...</span> <span class="pre">)</span></code> to have arguments different from the type that wants to be pushed, or <code class="docutils literal notranslate"><span class="pre">sol::stack::push(</span> <span class="pre">L,</span> <span class="pre">arg,</span> <span class="pre">args...</span> <span class="pre">)</span></code> where <code class="docutils literal notranslate"><span class="pre">T</span></code> will be inferred from <code class="docutils literal notranslate"><span class="pre">arg</span></code>. The final form of this function is <code class="docutils literal notranslate"><span class="pre">sol::stack::multi_push</span></code>, which will call one <code class="docutils literal notranslate"><span class="pre">sol::stack::push</span></code> for each argument. The <code class="docutils literal notranslate"><span class="pre">T</span></code> that describes what to push is first sanitized by removing top-level <code class="docutils literal notranslate"><span class="pre">const</span></code> qualifiers and reference qualifiers before being forwarded to the extension point <a class="reference internal" href="#pusher"><span class="std std-ref">stack::pusher&lt;T&gt;</span></a> struct.</p>
<div class="literal-block-wrapper docutils container" id="stack-push-reference">
<div class="code-block-caption"><span class="caption-text">function: push_reference</span><a class="headerlink" href="#stack-push-reference" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// push T inferred from call site, pass args... through to extension point</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">push_reference</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">item</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span>

<span class="c1">// push T that is explicitly specified, pass args... through to extension point</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Arg</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">push_reference</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">Arg</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span>

<span class="c1">// recursively call the the above &quot;push&quot; with T inferred, one for each argument</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">multi_push_reference</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<p>These functinos behave similarly to the ones above, but they check for specific criteria and instead attempt to push a reference rather than forcing a copy if appropriate. Use cautiously as sol2 uses this mainly as a return from usertype functions and variables to preserve chaining/variable semantics from that a class object. Its internals are updated to fit the needs of sol2 and while it generally does the “right thing” and has not needed to be changed for a while, sol2 reserves the right to change its internal detection mechanisms to suit its users needs at any time, generally without breaking backwards compatibility and expectations but not exactly guaranteed.</p>
<div class="literal-block-wrapper docutils container" id="stack-pop">
<div class="code-block-caption"><span class="caption-text">function: pop</span><a class="headerlink" href="#stack-pop" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">pop</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<p>Pops an object off the stack. Will remove a fixed number of objects off the stack, generally determined by the <code class="docutils literal notranslate"><span class="pre">sol::lua_size&lt;T&gt;</span></code> traits of the arguments supplied. Generally a simplicity function, used for convenience.</p>
<div class="literal-block-wrapper docutils container" id="stack-top">
<div class="code-block-caption"><span class="caption-text">function: top</span><a class="headerlink" href="#stack-top" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">top</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<p>Returns the number of values on the stack.</p>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">function: set_field</span><a class="headerlink" href="#id1" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">global</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Key</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Value</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">set_field</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">Key</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Value</span><span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="p">);</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">global</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Key</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Value</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">set_field</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">Key</span><span class="o">&amp;&amp;</span> <span class="n">k</span><span class="p">,</span> <span class="n">Value</span><span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">objectindex</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Sets the field referenced by the key <code class="docutils literal notranslate"><span class="pre">k</span></code> to the given value <code class="docutils literal notranslate"><span class="pre">v</span></code>, by pushing the key onto the stack, pushing the value onto the stack, and then doing the equivalent of <code class="docutils literal notranslate"><span class="pre">lua_setfield</span></code> for the object at the given <code class="docutils literal notranslate"><span class="pre">objectindex</span></code>. Performs optimizations and calls faster verions of the function if the type of <code class="docutils literal notranslate"><span class="pre">Key</span></code> is considered a c-style string and/or if its also marked by the templated <code class="docutils literal notranslate"><span class="pre">global</span></code> argument to be a global.</p>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">function: get_field</span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">global</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Key</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">get_field</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">Key</span><span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="p">[,</span> <span class="kt">int</span> <span class="n">objectindex</span><span class="p">]</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<p>Gets the field referenced by the key <code class="docutils literal notranslate"><span class="pre">k</span></code>, by pushing the key onto the stack, and then doing the equivalent of <code class="docutils literal notranslate"><span class="pre">lua_getfield</span></code>. Performs optimizations and calls faster verions of the function if the type of <code class="docutils literal notranslate"><span class="pre">Key</span></code> is considered a c-style string and/or if its also marked by the templated <code class="docutils literal notranslate"><span class="pre">global</span></code> argument to be a global.</p>
<p>This function leaves the retrieved value on the stack.</p>
<div class="literal-block-wrapper docutils container" id="stack-probe-get-field">
<div class="code-block-caption"><span class="caption-text">function: probe_get_field</span><a class="headerlink" href="#stack-probe-get-field" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">global</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Key</span><span class="o">&gt;</span>
<span class="n">probe</span> <span class="n">probe_get_field</span><span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">Key</span><span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="p">[,</span> <span class="kt">int</span> <span class="n">objectindex</span><span class="p">]</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<p>Gets the field referenced by the key <code class="docutils literal notranslate"><span class="pre">k</span></code>, by pushing the key onto the stack, and then doing the equivalent of <code class="docutils literal notranslate"><span class="pre">lua_getfield</span></code>. Performs optimizations and calls faster verions of the function if the type of <code class="docutils literal notranslate"><span class="pre">Key</span></code> is considered a c-style string and/or if its also marked by the templated <code class="docutils literal notranslate"><span class="pre">global</span></code> argument to be a global. Furthermore, it does this safely by only going in as many levels deep as is possible: if the returned value is not something that can be indexed into, then traversal queries with <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code>/<code class="docutils literal notranslate"><span class="pre">std::pair</span></code> will stop early and return probing information with the <a class="reference internal" href="#stack-probe-struct"><span class="std std-ref">probe struct</span></a>.</p>
<p>This function leaves the retrieved value on the stack.</p>
</div>
<div class="section" id="objects-extension-points">
<span id="extension-points"></span><h2>objects (extension points)<a class="headerlink" href="#objects-extension-points" title="Permalink to this headline">¶</a></h2>
<p>You can customize the way Sol handles different structures and classes by following the information provided in the <a class="reference internal" href="../tutorial/customization.html"><span class="doc">adding your own types</span></a>.</p>
<p>Below is more extensive information for the curious.</p>
<p>The structs below are already overriden for a handful of types. If you try to mess with them for the types <code class="docutils literal notranslate"><span class="pre">sol</span></code> has already overriden them for, you’re in for a world of thick template error traces and headaches. Overriding them for your own user defined types should be just fine, however.</p>
<div class="literal-block-wrapper docutils container" id="getter">
<div class="code-block-caption"><span class="caption-text">struct: getter</span><a class="headerlink" href="#getter" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">getter</span> <span class="p">{</span>
        <span class="k">static</span> <span class="n">T</span> <span class="n">get</span> <span class="p">(</span><span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">record</span><span class="o">&amp;</span> <span class="n">tracking</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// ...</span>
                <span class="k">return</span> <span class="c1">// T, or something related to T.</span>
        <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>This is an SFINAE-friendly struct that is meant to expose static function <code class="docutils literal notranslate"><span class="pre">get</span></code> that returns a <code class="docutils literal notranslate"><span class="pre">T</span></code>, or something convertible to it. The default implementation assumes <code class="docutils literal notranslate"><span class="pre">T</span></code> is a usertype and pulls out a userdata from Lua before attempting to cast it to the desired <code class="docutils literal notranslate"><span class="pre">T</span></code>. There are implementations for getting numbers (<code class="docutils literal notranslate"><span class="pre">std::is_floating</span></code>, <code class="docutils literal notranslate"><span class="pre">std::is_integral</span></code>-matching types), getting <code class="docutils literal notranslate"><span class="pre">std::string</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code>, getting raw userdata with <a class="reference internal" href="types.html"><span class="doc">userdata_value</span></a> and anything as upvalues with <a class="reference internal" href="types.html"><span class="doc">upvalue_index</span></a>, getting raw <a class="reference external" href="http://www.Lua.org/manual/5.3/manual.html#lua_CFunction">lua_CFunction</a> s, and finally pulling out Lua functions into <code class="docutils literal notranslate"><span class="pre">std::function&lt;R(Args...)&gt;</span></code>. It is also defined for anything that derives from <a class="reference internal" href="reference.html"><span class="doc">sol::reference</span></a>. It also has a special implementation for the 2 standard library smart pointers (see <a class="reference internal" href="usertype_memory.html"><span class="doc">usertype memory</span></a>).</p>
<div class="literal-block-wrapper docutils container" id="pusher">
<div class="code-block-caption"><span class="caption-text">struct: pusher</span><a class="headerlink" href="#pusher" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">pusher</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">push</span> <span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span>
                <span class="c1">// can optionally take more than just 1 argument</span>
                <span class="c1">// ...</span>
                <span class="k">return</span> <span class="c1">// number of things pushed onto the stack</span>
        <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>This is an SFINAE-friendly struct that is meant to expose static function <code class="docutils literal notranslate"><span class="pre">push</span></code> that returns the number of things pushed onto the stack. The default implementation assumes <code class="docutils literal notranslate"><span class="pre">T</span></code> is a usertype and pushes a userdata into Lua with a class-specific, state-wide metatable associated with it. There are implementations for pushing numbers (<code class="docutils literal notranslate"><span class="pre">std::is_floating</span></code>, <code class="docutils literal notranslate"><span class="pre">std::is_integral</span></code>-matching types), getting <code class="docutils literal notranslate"><span class="pre">std::string</span></code> and <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code>, getting raw userdata with <a class="reference internal" href="types.html"><span class="doc">userdata</span></a> and raw upvalues with <a class="reference internal" href="types.html"><span class="doc">upvalue</span></a>, getting raw <a class="reference external" href="http://www.Lua.org/manual/5.3/manual.html#lua_CFunction">lua_CFunction</a> s, and finally pulling out Lua functions into <code class="docutils literal notranslate"><span class="pre">sol::function</span></code>. It is also defined for anything that derives from <a class="reference internal" href="reference.html"><span class="doc">sol::reference</span></a>. It also has a special implementation for the 2 standard library smart pointers (see <a class="reference internal" href="usertype_memory.html"><span class="doc">usertype memory</span></a>).</p>
<div class="literal-block-wrapper docutils container" id="checker">
<div class="code-block-caption"><span class="caption-text">struct: checker</span><a class="headerlink" href="#checker" title="Permalink to this code">¶</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">type</span> <span class="n">expected</span> <span class="o">=</span> <span class="n">lua_type_of</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">checker</span> <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Handler</span><span class="o">&gt;</span>
        <span class="k">static</span> <span class="kt">bool</span> <span class="n">check</span> <span class="p">(</span> <span class="n">lua_State</span><span class="o">*</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Handler</span><span class="o">&amp;&amp;</span> <span class="n">handler</span><span class="p">,</span> <span class="n">record</span><span class="o">&amp;</span> <span class="n">tracking</span> <span class="p">)</span> <span class="p">{</span>
                <span class="c1">// if the object in the Lua stack at index is a T, return true</span>
                <span class="k">if</span> <span class="p">(</span> <span class="p">...</span> <span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                <span class="c1">// otherwise, call the handler function,</span>
                <span class="c1">// with the required 4 arguments, then return false</span>
                <span class="n">handler</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">indextype</span><span class="p">);</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>This is an SFINAE-friendly struct that is meant to expose static function <code class="docutils literal notranslate"><span class="pre">check</span></code> that returns the number of things pushed onto the stack. The default implementation simply checks whether the expected type passed in through the template is equal to the type of the object at the specified index in the Lua stack. The default implementation for types which are considered <code class="docutils literal notranslate"><span class="pre">userdata</span></code> go through a myriad of checks to support checking if a type is <em>actually</em> of type <code class="docutils literal notranslate"><span class="pre">T</span></code> or if its the base class of what it actually stored as a userdata in that index. Down-casting from a base class to a more derived type is, unfortunately, impossible to do.</p>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="resolve.html">resolve</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="user.html">light&lt;T&gt;/user&lt;T&gt;</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, ThePhD.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.0.
    </div>
  </body>
</html>